# Go语言程序基础
## 变量、常量、指针和赋值
### 变量
```go
var name [类型] = [表达式]
```
数字默认值是0
布尔值默认值是false
字符串默认值是""
接口、切片、指针、map通道和函数的默认值是nil
**变量的一些声明方式**
```go
// 多变量声明
var a,b,c int

// 多变量赋值
var a,b,c=1,true,"str"

// 声明赋值的缩写
a := 1

// 同时给两个变量赋值,这个也可以用来交换两个值
a,b := 1,2

```
### 常量
```go
// 单个常量声明
const NAME = "zhang san"

// 多个常量声明
const(
  ONE=1
  TWO=2
  THREE=3
  FOUR string="zhang san"
  
  AGE int32=18
  
  DONE bool=true
)
```
**常量生成器iota**
iota默认从0开始
```go
const(
  ZERO=iota // 0
  ONE       // 1
)
```
也可以花哨一点
```go
const(
  ZERO=iota<<2  // 0
  ONE           // 4
)
```
### 指针
go语言是类C语言，也有指针。但是go的指针相较于C来说简单得多。
go不支持指针的加减等操作。
```go
var a int32=1
p:=&a
fmt.Println(*p)

```
在go语言中，除非显示地使用指针，否则所有的值传递都是具体值的复制，包括数组等复合结构。
**new关键字**
go语言提供了`new`关键字来快捷提供指针。
```go
var str = "hello world"
var p = new(string)
p=&str
fmt.Println(*p)
```
### 赋值
```go
m:=1
m++
m-=1

m,n=n,m
x,y,z=1,2,3

file,_:=os.Open("text.txt")
```
## 包及其作用域
go使用`package`定义一个包，一个包意味着一个独立的命名空间。
go语言通过函数、变量首字母的大小写来控制可见性，首字母大写的才是包外可见的，首字母小写的是包内私有的。
go语言中标识符的命名规则为驼峰式，比如MakeFile。
程序中用到包的时候，使用`import`导入。
```go
// 导入包
import "fmt"

// 包别名
import f "fmt"

// 只使用包的初始化函数
import _ "gorm.io/driver/mysql"

// 调用时不使用报名
import . "fmt"

```
## 选择和循环
### 条件
**if...else...**
```go
if a==1{
  fmt.Println("1")
}else if{
  fmt.Println("2")
}else{
  fmt.Println("3")
}
```
**switch**
```go
var a int32 = 10
switch{
case a+1<10:
  s.Println("<10")
  fallthrough
case a==10:
  s.Println("=10")
case a>10:
  s.Println(">10")
default:
  s.Println("default")
}
```
`switch`的判别中可以有表达式，可以使用`fallthrough`运行下面的代码。
### 循环
go语言只有`for`循环。
```go
for i:=0;i<100;i++{
  // 循环体
}

for{
  // 循环体
}

for ok:=true;ok;ok=[表达式]{
  // 循环体
}
```
## 垃圾回收
go语言的垃圾回收是自动实现的。
当前比较著名的垃圾回收算法有引用计数（Reference Counting）、分代收集（Generation）、标记-清楚（Mark and Sweep）。
go语言使用的是三色标算法。
![](https://article.biliimg.com/bfs/article/69fbb3b834c4adbf23fd5b0cb96c0c06b3a8cd90.png)
三色标记法的原则就是把堆中的对象非陪到不同颜色的集合当中。而颜色（黑、白、灰）是根据算法标记的。
-   黑色集合：没有任何指针指向白色集合的对象集合
-   白色集合：允许有指针指向黑色集合
-   灰色集合：可能会有指针指向白色集合的对象
白色集合就是最后要回收的对象集合。
**垃圾回收步骤**
1.  所有对象进入白色集合
2.  找到根对象，放入灰色集合
3.  取出灰色集合的对象，把这些对象指向的对象取出放入灰色集合，自己则放入黑色集合。如此循环，直到灰色集合为空
4.  清理白色集合
go语言的垃圾回收是并行处理的，所以在不同集合之间移动的时候要考虑读写问题。go语言的垃圾回收是通过修改 器（Mutator）和写阻塞（Write Barrier）来完成的。
## 逃逸分析
一个变量是在堆上分配，还是在栈上分配，是经过编译器的`逃逸分析`之后得出的结论。
以前写C/C++代码时，为了提高效率，常常将`pass-by-value`（传值）“升级”成`pass-by-reference`，企图避免构造函数的运行，并且直接返回一个指针。 你一定还记得，这里隐藏了一个很大的坑：在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存会被销毁，任何对这个返回值作的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃。比如下面的这段代码：
```c
int *foo ( void )   
{   
    int t = 3;
    return &t;
}
```
你表面的光鲜，一定是背后有很多人为你撑起的！Go语言里就是编译器的`逃逸分析`。它是编译器执行静态代码分析后，对内存管理进行的优化和简化。在编译原理中，分析指针动态范围的方法称之为`逃逸分析`。
*通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。*
⚠️更简单来说，`逃逸分析`决定一个变量是分配在堆上还是分配在栈上。
**为什么要逃逸分析**
C/C++中动态分配的内存需要我们手动释放，导致猿们平时在写程序时，如履薄冰。
Go的垃圾回收，让堆和栈对程序员保持透明。真正解放了程序员的双手，让他们可以专注于业务，“高效”地完成代码编写。把那些内存管理的复杂机制交给编译器，而程序员可以去享受生活。
`逃逸分析`这种“骚操作”把变量合理地分配到它该去的地方，“找准自己的位置”。即使你是用`new`申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。真正地做到“按需分配”，提前实现共产主义！
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。
堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASSE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。
通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。
**逃逸分析是怎么完成的**
Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。
简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。
Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。
对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。套个取址符，就想骗补助？Too young！
简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：
1.  如果函数外部没有引用，则优先放到栈中；
2.  如果函数外部存在引用，则必定放到堆中；
    针对第一条，可能放到堆上的情形：定义了一个很大的数组，需要申请的内存过大，超过了栈的存储能力。
**逃逸分析实例**
```go
package main

import "fmt"

func foo() *int {
  t := 3
  return &t;
}

func main() {
  x := foo()
  fmt.Println(*x)
}
```
foo函数返回一个局部变量的指针，main函数里变量x接收它。执行如下命令：
`go build -gcflags '-m -l' main.go`
加`-l`是为了不让`foo`函数被内联。
得到如下输出：
```bash
# command-line-arguments* src/main.go:7:9: &t escapes to heap src/main.go:6:7: moved to heap: t src/main.go:12:14: *x escapes to heap src/main.go:12:13: main ... argument does not escape
```
`foo`函数里的变量`t`逃逸了，和我们预想的一致。让我们不解的是为什么`main`函数里的`x`也逃逸了？这是因为有些函数参数为`interface`类型，比如`fmt.Println(a …interface{})`，编译期间很难确定其参数的具体类型，也会发生逃逸。
使用反汇编命令也可以看出变量是否发生逃逸。
`go tool compile -S main.go`
截取部分结果，图中标记出来的说明`t`是在堆上分配内存，发生了逃逸。
堆上动态分配内存比栈上静态分配内存，开销大很多。
变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。
Go编译器会在编译期考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。
简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过`go build -gcflags '-m'`命令来观察变量逃逸情况就行了。
不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。
最后，尽量写出少一些逃逸的代码，提升程序的运行效率。
## Go语言内存分配
Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。
Golang运行时的内存分配算法主要源自Google为C语言开发的`TCMalloc算法`，全称`Thread-Caching Malloc`。核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。
**基础概念**
Go在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。
申请到的内存块被分配了三个区域，在X64上分别是512MB，16GB，512GB大小。
`arena区域`就是我们所谓的堆区，Go动态分配的内存都是在这个区域，它把内存分割成`8KB`大小的页，一些页组合起来称为`mspan`。
`bitmap区域`标识`arena`区域哪些地址保存了对象，并且用`4bit`标志位表示对象是否包含指针、`GC`标记信息。`bitmap`中一个`byte`大小的内存对应`arena`区域中4个指针大小（指针大小为 8B ）的内存，所以`bitmap`区域的大小是`512GB/(4*8B)=16GB`。
从上图其实还可以看到bitmap的高地址部分指向arena区域的低地址部分，也就是说bitmap的地址是由高地址向低地址增长的。
`spans区域`存放`mspan`（也就是一些`arena`分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以`spans`区域的大小就是`512GB/8KB*8B=512MB`。除以8KB是计算`arena`区域的页数，而最后乘以8是计算`spans`区域所有指针的大小。创建`mspan`的时候，按页填充对应的`spans`区域，在回收`object`时，根据地址很容易就能找到它所属的`mspan`。
**内存管理单元**
`mspan`：Go中内存管理的基本单元，是由一片连续的`8KB`的页组成的大块内存。注意，这里的页和操作系统本身的页并不是一回事，它一般是操作系统页大小的几倍。一句话概括：`mspan`是一个包含起始地址、`mspan`规格、页的数量等内容的双端链表。
每个`mspan`按照它自身的属性`Size Class`的大小分割成若干个`object`，每个`object`可存储一个对象。并且会使用一个位图来标记其尚未使用的`object`。属性`Size Class`决定`object`大小，而`mspan`只会分配给和`object`尺寸大小接近的对象，当然，对象的大小要小于`object`大小。还有一个概念：`Span Class`，它和`Size Class`的含义差不多，
`Size_Class **=** Span_Class **/** 2`
这是因为其实每个 `Size Class`有两个`mspan`，也就是有两个`Span Class`。其中一个分配给含有指针的对象，另一个分配给不含有指针的对象。这会给垃圾回收机制带来利好，之后的文章再谈。
如下图，`mspan`由一组连续的页组成，按照一定大小划分成`object`。
Go1.9.2里`mspan`的`Size Class`共有67种，每种`mspan`分割的object大小是8\*2n的倍数，这个是写死在代码里的：
![](https://user-images.githubusercontent.com/7698088/54070690-0b198a80-429e-11e9-8838-eef9cd160f5c.png#crop=0\&crop=0\&crop=1\&crop=1\&id=lf3L0\&originHeight=160\&originWidth=274\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)
```go
// path: /usr/local/go/src/runtime/sizeclasses.go
const _NumSizeClasses = 67

var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536,1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
```
根据`mspan`的`Size Class`可以得到它划分的`object`大小。 比如`Size Class`等于3，`object`大小就是32B。 32B大小的object可以存储对象大小范围在17B\~32B的对象。而对于微小对象（小于16B），分配器会将其进行合并，将几个对象分配到同一个`object`中。
数组里最大的数是32768，也就是32KB，超过此大小就是大对象了，它会被特别对待，这个稍后会再介绍。顺便提一句，类型`Size Class`为0表示大对象，它实际上直接由堆内存分配，而小对象都要通过`mspan`来分配。
对于mspan来说，它的`Size Class`会决定它所能分到的页数，这也是写死在代码里的：
```go
*// path: /usr/local/go/src/runtime/sizeclasses.go*
**const** _NumSizeClasses = 67

**var** class_to_allocnpages = [_NumSizeClasses]**uint8**{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4}
```
比如当我们要申请一个`object`大小为`32B`的`mspan`的时候，在class\_to\_size里对应的索引是3，而索引3在`class_to_allocnpages`数组里对应的页数就是1。
`mspan`结构体定义：
```go
*// path: /usr/local/go/src/runtime/mheap.go*
**type** mspan **struct** {
    *//链表前向指针，用于将span链接起来*
  next *****mspan  
  
  *//链表前向指针，用于将span链接起来*
  prev *****mspan  
  
  *// 起始地址，也即所管理页的地址*
  startAddr **uintptr** 
  
  *// 管理的页数*
  npages **uintptr** 
  
  *// 块个数，表示有多少个块可供分配*
  nelems **uintptr***//分配位图，每一位代表一个块是否已分配*
  allocBits *****gcBits 

    *// 已分配块的个数*
  allocCount **uint16** 
  
  *// class表中的class ID，和Size Classs相关*
  spanclass spanClass  

    *// class表中的对象大小，也即块大小*
  elemsize **uintptr** 
}
```
我们将`mspan`放到更大的视角来看：
![](https://user-images.githubusercontent.com/7698088/54192326-a440df00-44f2-11e9-950a-bbdfb7c36e62.png#crop=0\&crop=0\&crop=1\&crop=1\&id=iHD1W\&originHeight=702\&originWidth=1152\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)
上图可以看到有两个`S`指向了同一个`mspan`，因为这两个`S`指向的`P`是同属一个`mspan`的。所以，通过`arena`上的地址可以快速找到指向它的`S`，通过`S`就能找到`mspan`，回忆一下前面我们说的`mspan`区域的每个指针对应一页。
假设最左边第一个`mspan`的`Size Class`等于10，根据前面的`class_to_size`数组，得出这个`msapn`分割的`object`大小是144B，算出可分配的对象个数是`8KB/144B=56.89`个，取整56个，所以会有一些内存浪费掉了，Go的源码里有所有`Size Class`的`mspan`浪费的内存的大小；再根据`class_to_allocnpages`数组，得到这个`mspan`只由1个`page`组成；假设这个`mspan`是分配给无指针对象的，那么`spanClass`等于20。
`startAddr`直接指向`arena`区域的某个位置，表示这个`mspan`的起始地址，`allocBits`指向一个位图，每位代表一个块是否被分配了对象；`allocCount`则表示总共已分配的对象个数。
这样，左起第一个`mspan`的各个字段参数就如下图所示：
![](https://user-images.githubusercontent.com/7698088/54210478-87200680-451a-11e9-98dc-2e5adbb43d4a.png#crop=0\&crop=0\&crop=1\&crop=1\&id=D0nRP\&originHeight=298\&originWidth=150\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)
**内存管理组件**
内存分配由内存分配器完成。分配器由3种组件构成：`mcache`, `mcentral`, `mheap`。
1\. mcache
`mcache`：每个工作线程都会绑定一个mcache，本地缓存可用的`mspan`资源，这样就可以直接给Goroutine分配，因为不存在多个Goroutine竞争的情况，所以不会消耗锁资源。
`mcache`的结构体定义：
```go
*//path: /usr/local/go/src/runtime/mcache.go*
**type** mcache **struct** {
    alloc [numSpanClasses]*****mspan
}

numSpanClasses = _NumSizeClasses **<<** 1
```
`mcache`用`Span Classes`作为索引管理多个用于分配的`mspan`，它包含所有规格的`mspan`。它是`_NumSizeClasses`的2倍，也就是`67*2=134`，为什么有一个两倍的关系，前面我们提到过：为了加速之后内存回收的速度，数组里一半的`mspan`中分配的对象不包含指针，另一半则包含指针。
对于无指针对象的`mspan`在进行垃圾回收的时候无需进一步扫描它是否引用了其他活跃的对象。 后面的垃圾回收文章会再讲到，这次先到这里。
![](https://user-images.githubusercontent.com/7698088/54191324-a86bfd00-44f0-11e9-9039-3b64d39036d9.png#crop=0\&crop=0\&crop=1\&crop=1\&id=NpADe\&originHeight=630\&originWidth=1330\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)

`mcache`在初始化的时候是没有任何`mspan`资源的，在使用过程中会动态地从`mcentral`申请，之后会缓存下来。当对象小于等于32KB大小时，使用`mcache`的相应规格的`mspan`进行分配。
1.  mcentral
`mcentral`：为所有`mcache`提供切分好的`mspan`资源。每个`central`保存一种特定大小的全局`mspan`列表，包括已分配出去的和未分配出去的。 每个`mcentral`对应一种`mspan`，而`mspan`的种类导致它分割的`object`大小不同。当工作线程的`mcache`中没有合适（也就是特定大小的）的`mspan`时就会从`mcentral`获取。
`mcentral`被所有的工作线程共同享有，存在多个Goroutine竞争的情况，因此会消耗锁资源。结构体定义：
```go
//path: /usr/local/go/src/runtime/mcentral.go

type mcentral struct {
    // 互斥锁
    lock mutex 
    
    // 规格
    sizeclass int32 
    
    // 尚有空闲object的mspan链表
    nonempty mSpanList 
    
    // 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表
    empty mSpanList 
    
    // 已累计分配的对象个数
    nmalloc uint64 
}
```
`empty`表示这条链表里的`mspan`都被分配了`object`，或者是已经被`cache`取走了的`mspan`，这个`mspan`就被那个工作线程独占了。而`nonempty`则表示有空闲对象的`mspan`列表。每个`central`结构体都在`mheap`中维护。
简单说下`mcache`从`mcentral`获取和归还`mspan`的流程：
![](https://user-images.githubusercontent.com/7698088/54211962-2219e000-451d-11e9-85e1-0e8200925fa5.png#crop=0\&crop=0\&crop=1\&crop=1\&id=sdioa\&originHeight=630\&originWidth=1184\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)
-   获取 加锁；从`nonempty`链表找到一个可用的`mspan`；并将其从`nonempty`链表删除；将取出的`mspan`加入到`empty`链表；将`mspan`返回给工作线程；解锁。
-   归还 加锁；将`mspan`从`empty`链表删除；将`mspan`加入到`nonempty`链表；解锁。
1.  mheap
`mheap`：代表Go程序持有的所有堆空间，Go程序使用一个`mheap`的全局对象`_mheap`来管理堆内存。
当`mcentral`没有空闲的`mspan`时，会向`mheap`申请。而`mheap`没有资源时，会向操作系统申请新内存。`mheap`主要用于大对象的内存分配，以及管理未切割的`mspan`，用于给`mcentral`切割成小对象。
同时我们也看到，`mheap`中含有所有规格的`mcentral`，所以，当一个`mcache`从`mcentral`申请`mspan`时，只需要在独立的`mcentral`中使用锁，并不会影响申请其他规格的`mspan`。
`mheap`结构体定义：
```go
*//path: /usr/local/go/src/runtime/mheap.go*
**type** mheap **struct** {
  lock mutex
  
  *// spans: 指向mspans区域，用于映射mspan和page的关系*
  spans []*****mspan 
  
  *// 指向bitmap首地址，bitmap是从高地址向低地址增长的*
  bitmap **uintptr***// 指示arena区首地址*
  arena_start **uintptr** 
  
  *// 指示arena区已使用地址位置*
  arena_used  **uintptr** 
  
  *// 指示arena区末地址*
  arena_end   **uintptr** 

  central [67*****2]**struct** {
    mcentral mcentral
    pad [sys.CacheLineSize **-** unsafe.**Sizeof**(mcentral{})**%**sys.CacheLineSize]**byte**
  }
}
```
上图我们看到，bitmap和arena\_start指向了同一个地址，这是因为bitmap的地址是从高到低增长的，所以他们指向的内存位置相同。
![](https://user-images.githubusercontent.com/7698088/54213273-1cbd9500-451f-11e9-93e4-28f39615b6a2.png#crop=0\&crop=0\&crop=1\&crop=1\&id=uJn0b\&originHeight=1248\&originWidth=1386\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)
**内存分配流程**
变量是在栈上分配还是在堆上分配，是由逃逸分析的结果决定的。通常情况下，编译器是倾向于将变量分配到栈上的，因为它的开销小，最极端的就是"zero garbage"，所有的变量都会在栈上分配，这样就不会存在内存碎片，垃圾回收之类的东西。
Go的内存分配器在分配对象时，根据对象的大小，分成三类：小对象（小于等于16B）、一般对象（大于16B，小于等于32KB）、大对象（大于32KB）。
大体上的分配流程：
-   32KB 的对象，直接从mheap上分配；
-   <=16B 的对象使用mcache的tiny分配器分配；
-   (16B,32KB] 的对象，首先计算对象的规格大小，然后使用mcache中相应规格大小的mspan分配；
    -   如果mcache没有相应规格大小的mspan，则向mcentral申请
    -   如果mcentral没有相应规格大小的mspan，则向mheap申请
    -   如果mheap中也没有合适大小的mspan，则向操作系统申请
        Go语言的内存分配非常复杂，它的一个原则就是能复用的一定要复用。源码很难追，后面可能会再来一篇关于内存分配的源码阅读相关的文章。简单总结一下本文吧。
        文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也可以了。
-   Go在程序启动时，会向操作系统申请一大块内存，之后自行管理。
-   Go内存管理的基本单元是mspan，它由若干个页组成，每种mspan可以分配特定大小的object。
-   mcache, mcentral, mheap是Go内存管理的三大组件，层层递进。mcache管理线程在本地缓存的mspan；mcentral管理全局的mspan供所有线程使用；mheap管理Go的所有动态分配内存。
-   极小对象会分配在一个object中，以节省资源，使用tiny分配器分配内存；一般小对象通过mspan分配内存；大对象则直接由mheap分配内存。
# 基本数据类型
go语言有四种基本的数据类型，分别是基本数据类型、复合数据类型、引用数据类型以及接口数据类型。
基本数据类型有整型、浮点型、布尔型、复数和常量。
![](https://article.biliimg.com/bfs/article/54ffc91cf1ec3944d41b0cb5132b7411428ddfa8.png)

## 整型
go语言中直接定义数位的类型，包括rune、int8、int16、int32、int64和byte、uint8、uint16、uint32、uint64等。
rune是int32的别名，使用utf-8进行编码。如果要访问字符串中的字符，比如遍历字符串中的每个字符，可以使用这个类型。
## 运算符
特别注意运算符`&^`表示位清空（AND NOT）
## 浮点型
go语言支持的浮点型有float32和float64。
⚠️float32的精度不准，这是因为float32是按照默认小数位输出的，但是默认的小数位并不准确。所以多多使用float64。
## 复数
复数有complex64和complex128，他们分别由float32和float64组成。
复数有实部和虚部分组成，内置的函数`real()`和`imag()`可以用来分别获取复数的实部和虚部。
## 布尔值
go语言的布尔值只支持true和false，不可以使用0和1来代替。
## 格式化说明符
-   `%d`格式化整数
-   `%g`格式化浮点数
-   `%0d`输出定长整型
-   `%n.mg`表示数字n精确到m位
# 字符串和复合数据类型
## 字符串
字符串是不可改变的字节序列，类似于一个定长的数组。
在go语言的底层代码中是这样的：
```go
type StringHeader struct{
  Data uintptr // 底层字节数组
  Len  int     // 字节长度
}
```
**常用的包**
-   strings：提供搜索、比较、切分与字符串连接等功能。
-   bytes：如果要对字符串的底层字节进行操作，可以使用\[]bytes转换类型后进行处理。
-   strconv：主要是字符串与其他类型的转换，比如整数、布尔。
-   unicode：主要是对字符串中的单个字符做判断，比如 IsLetter、IsDigit、IsUpper等。
字符串可以强制转换为\[]bytes和\[]rune这两种类型进行处理。不管是哪种转换，系统都需要付出多分配一块内存的代价。可是如果需要对字符串进行新增字符等操作，转换到\[]bytes后可以使用`bytes.Buffer`的`writeRune`方法；而转换到\[]rune则会多做一些检查，会要求底层尽可能保持一致。
## 数组
**数组的定义方式**
```go
// 数组长度明确，初始值都是0；
var a [3]int

// 在初始化的时候指定所有元素的初始值，数组长度根据初始化元素的数目自动计算；
var b [...]int{1,2,3}

// 以索引的方式创建数组，数组的长度以出现的最大索引为准，没有明确初始化的元素依然用0初始化；
var c [...]int{2:3,1:2}

// 顺序初始化、零初始化和索引初始化并用。
var d [...]int{1,2,4:5,6}
```
go语言的数组是值语义，并不像是C语言那样指数组的第一个元素的指针，而是表示一个完整的值。当一个数值变量被赋值或者被传递的时候，会复制整个数组，开销很大，因此经常使用一个指向数组的指针。但是数组指针并不是数组。
使用`len()`函数计算数组的长度；用`cap()`函数计算数组的容量；但是在数组中，二者相等。
**数组的遍历**
1. 方式1
```go
for i := range a{
  fmt.Printf("%d", a[i])
}
```
2. 方式2
```go
for i,j := range array{
  fmt.Printf("%d ",array[i])
  fmt.Printf("%d ",j)
}
```
3. 方式3
```go
for i:=0;i<len(array);i++{
  fmt.Println(array[i])
}
```
使用`for...range`方式遍历数组可以保证数组不会越界。但是这样的遍历方式是复制后遍历，复制的过程会加大消耗，效率会低一点。
长度为0的数组（空数组）在内存中并不占用空间。
⚠️go语言中数组的传递方式是值传递，为了节约性能请使用引用传递。
## 切片
简单的说，切片就是一个简化版的动态数组。
切片源代码：
```go
type slice struct {
  array unsafe.Pointer // 元素指针
  len   int // 长度 
  cap   int // 容量
}
```
slice共有三个属性：
1.  指针，指向底层数组；
2.  长度，表示切片可用元素的个数，也就是说使用下标对slice的元素进行访问时，下标不能超过slice的长度；
3.  容量，底层数组的元素个数，容量>=长度。在底层数组不进行扩容的情况下，容量也是slice可以扩张的最大限度。
注意，底层数组是可以被多个slice同时指向的，因此对一个slice的元素进行操作是有可能影响到其他slice的。
**Slice的创建**
```go
1.直接声明
var slice []int

2.new 
slice:=new([]int)

3.字面量
slice := []int{1,2,3,4,5}

4.make
slice := make([]int, 5, 10)

5.从切片或数组“截取”
slice := array[1:5] 或 slice := sourceSlice[1:5]
```
**切片的初始化**
切片的底层是数组，这意味着Go为每一个切片都会创建一个底层数组。
```go
// nil切片和nil相等，一般用来表示一个不存在的切片
a[] int

// 空切片和nil不相等，一般用来表示一个空的集合
b = [] int{}

// 有3个元素的切片，len和cap都为3
c = []int{1, 2, 3}

// 有2个元素的切片，len为2，cap为3
d = c[: 2]

e = c[0:2:cap(c)]

// 有0个元素的切片，len为0，cap为3
f = c[: 0]

// 有3个元素的切片，len和cap都为3
g = make([]int, 3)

// 有2个元素的切片，len为2，cap为3
h = make([]int, 2, 3)

// 有0个元素的切片，len为0，cap为3
i = make([]int,0,3)
```
**切片的基本操作**
```go
// 追加元素1，2，3
a = append(a, 1, 2, 3)

// 追加一个切片
a = append(a, []int{1, 2, 3})

// 在开头添加元素
slice1 := []int{1, 2, 3}
slice2 := append([]int{0, 0, 0, 0, 0}, slice1...)

// 在第3位置插入元素
a := []int{1, 2, 3, 4, 5}
a = append(a[:3], append([]int{9}, a[3:]...)...)

// 把第二个数往后移动，重新赋值
a := []int{1, 2, 3, 4, 5}
copy(a[2+1:], a[2:])
a[2] =0

// 删除尾部1个元素
a = a[:len(a)-1]

// 删除尾部N个元素
a = a[:len(a)-N]

// 删除开头1个元素
a = a[1:]
a = a[:copy(a, a[1:])]

// 删除开头N个元素
a = a[N:]
a = a[:copy(a, a[N:])]

// 删除中间1个元素
a = append(a[:i], a[i+1:]...)

// 删除中间N个元素
a = append(a[:i], a[i+N:]...)

// 切片强制类型转换
var a = []float64{4, 2, 5, 7, 2, 1, 88, 1}
```
**切片排序**
-   方式1
```go
func SortFloat64FastV1(a []float64) {
  var b[] int = ((*[1<<20]int)(unsafe.Pointer(&a[0])))[:len(a):cap(a)]
  // 以int方式给float64排序
  sort.Ints(b)
}
```
-   方式2
```go
func SortFloat64FastV2(a []float64) {
  // 通过 reflect.SliceHeader 更新切片头部信息实现转换
  var c []int
  aHdr := (*reflect.SliceHeader)(unsafe.Pointer(&a))
  cHdr := (*reflect.SliceHeader)(unsafe.Pointer(&c))
  *cHdr = *aHdr
  // 以int方式给float64排序
  sort.Ints(c)
}
```
**切片的扩容**
为了减少内存的拷贝次数，容量在比较小的时候，一般是以2的倍数扩大的，例如2 4 8 16 …，当达到1024时，会采取新的策略，避免申请内存过大，导致浪费。 切片的容量可以使用`cap()`函数获得。
1.  当容量小于等于1024时
    ```go
    func main() {
        slice := make([]int, 4)
        fmt.Println("初始化时切片的容量是：", cap(slice))
        slice = append(slice, 1)
        fmt.Println("扩容后切片的容量是：", cap(slice))
    }

    /*
    * 初始化时切片的容量是： 4
    * 扩容后切片的容量是： 8
    */
    ```
2.  当容量大于1024时
    ```go
    ```
⚠️长度和容量都为0的切片并不能等于nil，不能用是否等于nil进行判断，而是需要根据长度和容量进行判断。
## map
map（映射）示go语言提供的key-value（键值对）形式的无序集合。键值对的键有唯一性要求。
map的底层是一个Hash表。
**创建map**
```go
// key是string类型，value是int32类型
mp:=make(map[string]int32)

```
**删除map**
```go
// 删除map中的key是one的值
delete(mp，"one")

```
⚠️map在元素赋值之前必须初始化，要么用make函数，要么声明时就初始化。
⚠️map的遍历顺序不是固定的，如果需要排序，可以对map的key进行排序。
## struct
**定义struct**
```go
// 定义结构体
type People struct{
  name string
  age int32
}

// 初始化
var p1 People
p2:=People("张三",19)
p3:=People(name:"张三",age:19)
```
⚠️struct的可见性也是通过首字母大小写控制的。使用点（`.`）来访问成员变量。
结构体是占用一块连续的内存，一个结构体变量的大小是由结构体中的字段决定。可以用`unsafe`包里的`unsafe.Sizeof(p)`方法输出结构体的大小。
*内存对齐*：Go在编译的时候会按照一定的规则自动进行内存对齐。之所以这么设计是为了减少CPU访问内存的次数，加大CPU访问内存的吞吐量。如果不进行内存对齐的话，很可能就会增加CPU访问内存的次数。因为CPU访问内存时，并不是逐个字节访问，而是以字（word）为单位访问。比如64位CPU的字长（word size）为8 bytes，那么CPU访问内存的单位也是8字节，每次加载的内存数据也是固定的若干字长，如8 words(64bytes)、16 words(128bytes)等。
*对齐保证*：我们上面已经知道了可以通过内置`unsafe`包的`Sizeof()`函数来获取一个变量的大小，此外我们还可以通过内置`unsafe`包的`Alignof()`函数来获取一个变量的对齐系数。
*空结构体字段对齐*：如果结构或数组类型不包含大小大于零的字段（或元素），则其大小为0，空结构体不占用内存。两个不同的0大小变量在内存中可能有相同的地址。空结构体`struct{}`的大小为0，所以当一个结构体中包含空结构体类型的字段时，通常不需要进行内存对齐。例如：
```go
 type Demo1 struct {
     m struct{} // 0
     n int8     // 1
 }
 
 var d1 Demo1
 fmt.Println(unsafe.Sizeof(d1))  // 1
```
但是当空结构体类型作为结构体的最后一个字段时，如果有指向该字段的指针，那么就会返回该结构体之外的地址。为了避免内存泄露会额外进行一次内存对齐。
```go
 type Demo2 struct {
     n int8     // 1
     m struct{} // 0
 }
 
 var d2 Demo2
 fmt.Println(unsafe.Sizeof(d2))  // 2
```
## JSON
JSON（JavaScript Object Notation）是一种信息传递的标准。
go语言对JSON提供了很好的支持，encoding/json、encoding/xml和encoding/asn1等包都是用于处理JSON的。
# 函数、方法和接口
## 函数
**函数的定义**
```go
// 无参数函数
func GetMax(){
  // 函数题
}

// 有参数、有返回值函数
func GetMax(a int32, b int32) int32{
  if a>=b{
    return a
  }else{
    return b
  }
}

```
**闭包**
闭包是由函数及其相关引用环境组合而成的实体，即：`闭包 = 函数 + 引用环境`
一般的函数都有函数名，但是匿名函数就没有。匿名函数不能独立存在，但可以直接调用或者赋值于某个变量。匿名函数也被称为闭包，一个闭包继承了函数声明时的作用域。在Golang中，所有的匿名函数都是闭包。
```go
package main

import (
  "fmt"
)

func funReturnFun() func() int {
  i := 0
  return func() int {
    i++
    return i * i
  }
}

func main() {
  i := funReturnFun()
  j := funReturnFun()
  fmt.Println("1:", i())
  fmt.Println("2:", i())
  fmt.Println("j1:", j())
  fmt.Println("j2:", j())
  fmt.Println("3:", i())
}
```
**函数作为闭包**
```go
 package main
 
 import "fmt"
 
 func function1(i int) int {
   return i + i
 }
 
 func function2(i int) int {
   return i * i
 }
 
 func funFun(f func(int) int, v int) int {
   return f(v)
 }
 
 func main() {
   fmt.Println("function1:", funFun(function1, 123))
   fmt.Println("function2:", funFun(function2, 123))
   fmt.Println("Inline:", funFun(func(i int) int { return i * i * i }, 123))
 }
```
**作用域**

**多返回值及变长参数**

**defer关键字**
defer关键字的作用是当外围函数返回之后才执行被推迟的函数。 defer函数在外围函数返回之后，以后进先出(LIFO)的原则执行。
```go
package main

import "fmt"

func main() {
  var whatever [3]struct{}

  for i := range whatever {
    defer func() {
      fmt.Println(i)
    }()
  }
}
```
输出结果：
```bash
2
2
2
```
分析：defer后面跟的是一个闭包，i是“引用”类型的变量，最后i的值为2, 因此最后打印了三个2。
```go
package main

import "fmt"

type number int

func (n number) print()   { fmt.Println(n) }
func (n *number) pprint() { fmt.Println(*n) }

func main() {
  var n number
  defer n.print()
  defer n.pprint()
  defer func() { n.print() }()
  defer func() { n.pprint() }()
  n = 3
}
```
输出结果：
```go
3
3
3
0
```
分析：第四个defer语句是闭包，引用外部函数的n, 最终结果是3; 第三个defer语句同第四个； 第二个defer语句，n是引用，最终求值是3. 第一个defer语句，对n直接求值，开始的时候n=0, 所以最后是0。
**defer的应用**
有些情况下，我们会故意用到defer的先求值，再延迟调用的性质。想象这样的场景：在一个函数里，需要打开两个文件进行合并操作，合并完后，在函数执行完后关闭打开的文件句柄。
```go
func mergeFile() error {
  f, _ := os.Open("file1.txt")
  if f != nil {
    defer func(f io.Closer) {
      if err := f.Close(); err != nil {
        fmt.Printf("defer close file1.txt err %v\\n", err)
      }
    }(f)
  }

  // ……

  f, _ = os.Open("file2.txt")
  if f != nil {
    defer func(f io.Closer) {
      if err := f.Close(); err != nil {
        fmt.Printf("defer close file2.txt err %v\\n", err)
      }
    }(f)
  }

  return nil
}
```
## 方法
go语言中方法就是结构体的函数。
## 接口
**定义接口**
```go
 type Shape interface{
   Area() float64
   Length() float64
 }
```
go语言的接口是隐式实现的，某个结构体只要实现了接口的全部方法就表明实现了该接口。
**类型断言**
类型断言的表示方法是`x.(T)`，其中x是接口类型的变量，T是要判断的类型。也就是说，存储在x接口类型的变量中的实际值是T类型，并且T必须满足x的接口类型变量。
```go
 package main
 
 import "fmt"
 
 func main() {
   var a interface{} = 123
   i := a.(int)
   fmt.Printf("i: %v\\\\n", i)
 }
```
## 反射
反射（reflect）是go语言动态获取对象类型及结构信息的方式。
反射是一种高级的Go语言特性，它允许动态地获取任意对象的类型及其结构信息。Go语言通过`reflect`包提供用于处理反射的能力。不过应该记住的是，您很可能不需要在每个Go程序中使用反射。
```go
package main
 
import (
  "fmt"
  "reflect"
)
 
func main() {
  var i int32 = 10
  v := reflect.TypeOf(i)
  v2 := reflect.ValueOf(i)
  fmt.Printf("v: %v\\\\n", v)
  fmt.Printf("v2: %v\\\\n", v2)
}
```
**通过反射获取Tag标签**
```go
package main

import (
  "fmt"
  "log"
  "reflect"
)

type Person struct {
  Name string `json:"name" bson:"Name"`
  Age  int    `json:"age" bson:"Age"`
}

func main() {
  person := Person{
    Name: "张三",
    Age:  19,
  }
  personType := reflect.TypeOf(person)
  fieldName, isOk := personType.FieldByName("Name")
  if isOk {
    jsonTag := fieldName.Tag.Get("json")
    bsonTag := fieldName.Tag.Get("bson")
    fmt.Println("Name Json Tag =", jsonTag, "Bson Tag =", bsonTag)
  } else {
    fmt.Println("No Name Field")
  }
  fieldAge, isOk := personType.FieldByName("Age")
  if isOk {
    jsonTag := fieldAge.Tag.Get("json")
    bsonTag := fieldAge.Tag.Get("bson")
    fmt.Println("Name Json Tag =", jsonTag, "Bson Tag =", bsonTag)
  } else {
    fmt.Println("No Age Field")
  }
}
```
**反射的缺点**
毫无疑问，反射是Go语言一个强大的功能。然而，由于所有工具都使用反射，因此应谨慎使用，主要有三个原因：
1.  第一个原因是反射的广泛使用会使程序难以阅读和维护。这个问题的一个潜在解决方案是编写好的文档；但众所周知的是开发人员并不愿意花时间来编写维护文档。
2.  第二个原因是使用反射的Go代码会使程序运行变慢。一般来说，用于特定数据类型的Go代码总是比使用反射动态处理Go数据类型的代码运行速度快。此外，这样的动态代码将使工具很难重构或分析代码。
3.  最后一个原因是反射错误在编译时无法捕获，并且运行时会造成panic异常。这意味着反射的错误可能会使程序崩溃！这可能发生在Go程序开发完成后的数月甚至数年后！这个问题的一个解决办法是在危险函数调用之前进行全面的测试。然而，这将为Go程序增加更多的代码，使程序运行的更慢。
# 并发编程
## 竞态与并发模式
**竞态**
竞态就是在多线程的编程中，你在同一段代码里输入了相同的条件，但是会输出不确定的结果的情况。
⚠️在写代码的时候要避免所有出现数据竞态。
**如何避免竞态？**
数据竞态的产生是因为多个goroutine同时访问同一个变量，而且至少有一个goroutine会修改变量。可以根据数据竞态发生的条件来寻找解决竞态问题的方法。
1.  不修改变量（不可行）
2.  避免让多个goroutine读取一个变量，即只让一个goroutine访问该变量
3.  互斥访问
⚠️go 语言的多线程模式所提倡的就是：不要通过共享内存进行通信，而是要通过通信来共享内存。
## 并发原理
go语言也支持内存共享的并发方式，但这不是go语言所倡导的，在并发编程中应该优先使用通信顺序进程方式，也叫CSP（Communicating Sequential Process）方式。CSP既是一个技术名词，也是介绍该技术的论文的名字。该技术由Charles Antony Richard Hoare于1978年在ACM发表的同名论文中首次提出。CSP的理念也是go语言的座右铭：“不要以共享内存的方式实现通信，而应该以通信的方式实现共享内存”。
go语言的CSP是通过goroutine和channel实现的。
![](https://article.biliimg.com/bfs/article/8fa9d6335450cbc4cb4bd51cad70636d4677b136.png)
当通道为空时，读取的goroutine会阻塞；而当channel容量变满时，写入的goroutine也会阻塞。
## 协程
go语言的协程就是一种轻量级线程或者说是类协程。
Goroutine是go语言特有的并发体，是一种轻量级的线程，由`go`关键字启动。
协程本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中自行实现调度器。首先，每个系统级线程都会有一个固定大小的栈（一般默认可能是2MB），这个栈主要用来保存函数递归调用时参数和局部变量。
固定了栈的大小导致了两个问题：一是对于很多只需要很小的栈空间的线程来说是一个巨大的浪费，二是对于少数需要巨大栈空间的线程来说又面临栈溢出的风险。 针对这两个问题的解决方案是：要么降低固定的栈大小，提升空间的利用率；要么增大栈的大小以允许更深的函数递归调用，但这两者是没法同时兼得的。
相反，一个Goroutine会以一个很小的栈启动（可能是2KB或4KB），当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小（主流实现中栈的最大值可达到1GB）。因为启动的代价很小，所以我们可以轻易地启动成千上万个Goroutine。
goroutine调度的切换不用陷入（trap）操作系统内核层完成，代价很低。
但是对于操作系统来说，Go语言程序也只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠go自己完成。而将goroutine按照一定算法放到cpu上执行的程序就称为goroutine调度器（goroutine she scheduler）。
### 进程、线程和协程的关系
Goroutine比线程更轻量(是一种用户态线程)，而线程比进程更轻量。实际上，一个进程可以有多个线程以及许多Goroutine，而Goroutine需要一个进程的环境才能存在。因此，为了创建一个Goroutine，你需要有一个进程且这个进程至少有一个线程———Unix负责进程和线程管理，而Go工程师只需要处理Goroutine，这极大的降低了开发的成本。
### Go调度器
goroutine的运行机制是基于M：N的调度方式实现的，即有M个go语言运行时绿色线程映射到N个操作系统线程，而goroutine运行在绿色线程之上。若goroutine数量超过绿色线程数，调度程序会行使调度作用，确保部分goroutine阻塞且让之前处于等待状态的程序运行，如此往复，充分利用。
使用M、P和G分别代表系统线程、运行时绿色线程和goroutine。
M：Machine，一个M关联一个内核线程
P：Processor，用户代码的逻辑上的处理器，是M和G调度所需要的上下文，P的数量由GOMAXPROCS决定，通常来说是CPU的核芯数
G：goroutine，是运行在运行时绿色线程之上的轻量级线程
![](https://article.biliimg.com/bfs/article/11d6d3228bed90fc42268f550b964ca154543d20.png)
上图展示的是两个系统线程，也就是两个M。每个M对应一个内核线程， 同时每个M还会连接一个P作为上下文，这个P是逻辑上的处理器，P上面可以运行一个或多个goroutine。P就是前面说的运行时绿色线程，作为内核线程的M是不能直接运行goroutine的，要先有上下文。
P的数量由启动时环境变量GOMAXPROCS的值确定，通常情况下，此数量在程序运行期间不会改变。既然P的数量在运行时基本不变，那么也就意味着用来运行goroutine的运行时绿色线程是不变的，或者说运行Go代码的上下文是不变的，比如四核的处理器上就有四个运行时绿色线程运行go代码。
上图运行的goroutine是左侧的M、P、G,而右侧带底纹的G代表在等待状态的goroutine，可以看到，处于等待状态的goroutine排成了一个队列。
为什么一定需要P呢，让goroutine 直接运行在M上不可以吗？当然不可以，因为如果goroutine直接挂载在M上，就会严重依赖于M，一旦某个M阻塞，很可能会导致很多goroutine阻塞。而当中有了P这一层，即便有某个M阻塞，只要还有M可以运行，那么P就可以带着上下文信息便利地在M上开始运行。
P在运行的过程中还起着负载均衡的作用，一旦自己的goroutine队列运行完毕，还会去找其他的P的队列，会从其他队列分一部分过来。
Unix内核调度程序负责程序线程的执行。另一方面，Go运行时也有自己的调度程序，它使用称为 m:n的调度技术负责执行Goroutine，使用多路复用使n个操作系统线程执行m个Goroutine。Go调度程序是Go的组件，负责Go程序中Goroutine的执行方式和执行顺序。这使得Go调度程序成为Go编程语言中非常重要的一部分，因为Go程序中很多都是作为Goroutine执行的。需要留意的是，由于Go调度程序仅处理单个程序的Goroutine，因此其操作比内核调度程序的操作更简单，更轻量，更快。
**使用Channel实现并发示例**
```go
package main

import (
  "fmt"
  "time"
)

var ch = make(chan int, 10)

func main() {
  go mut()
  go add()
  time.Sleep(time.Second * 10)
}

func add() {
  for i := 0; i < 10; i++ {
    fmt.Println("新增：", i)
    ch <- i
  }
}

func mut() {
  for i := 0; i < 10; i++ {
    a := <-ch
    fmt.Println("取出：", a)
  }
}
```
可以使用`select`关键字对并发的协程进行处理。
### sync包
**sync.WaitGroup**
```go
package main

import (
  "fmt"
  "sync"
)

func main(){
  var wg sync.WaitGroup
  for i:=0;i<20;i++{
    wg.Add(1)
    go func(x int){
      defer wg.Done()
      fmt.Println(" ",x)
    }(i)
  }
  wg.Wait()
}
```
**sync.Mutex互斥锁**
```go
var m sync.Mutex
m.Lock()
m.Unlock()
```
⚠️sync.Mutex的加锁和开锁必须是成对的，如果加锁后忘记开锁，那么程序会崩溃。
**sync.RWMutex**
syc.RWMutex允许读操作并行执行，而写操作仍然是互斥的，通过这种方式可以提高效率。
**sync.Once**
sync.Once提供了延迟初始化的功能，延迟初始化可以提高系统启动的速度，也可以保证只初始化一次。
**sync.Cond**

**sync.Pool**

**sync.Map**

### context包
context包是go语言并发中经常用到的包，用于设置截至日期、同步“信号”、传递请求相关的值。
（还得细看，已经做了书签）
## 工作池

## 通道
通道（channel）是go语言提供的一种在goroutine之间进行数据传输的通信机制。
声明通道使用`chan`关键字，关闭则使用`close()`函数。
channel的默认初始值是nil。
**写入数据**
```go
// 声明channel
var ch = make(chan int32)
// 写入数据
ch<-1

```
**读出数据**
```go
var a int32
a <-ch
```
⚠️当主goroutine结束的时候，所有其他的goroutine也会结束。
⚠️channel没必要像文件那样主动close，因为垃圾回收会处理。
**以channel作为函数参数**
将channel作为函数参数的话，有两种方式：无方向通道和双向通道。
```go
func one(c chan int, x int){
  fmt.Println(x)
  c<-x
}

// 有方向的
func two(c chan<-int, x int){
  fmt.Println(x)
  c<-x
}
```
**缓存channel**
带有缓存的channel会像队列一样的方式输出。
```go
var ch = make(chan int,3)
```
⚠️通道关闭后仍然可以接收通道的数据，直到通道为空，继续接收则会让对应的操作结束。而向关闭后的通道发送数据则会导致异常。
### select
`select`关键字非常强大，它可以在各种情况下做很多事情。Go中的`select`语句看起来像channels的`switch`语句。实际上，这意味着`select`允许goroutine等待多个通信操作。因此，从`select`获得的主要好处就是它使您能够使用一个`select`块处理多个channels。因此，可以在channels上进行非阻塞操作。
⚠️注意：`select`语句不需要`default`。
`select`语句不是按顺序计算的，因为所有的channels都是同时检查的。如果在`select`语句中没有channels是准备好的，那么`select`语句就会阻塞，直到有一个channels准备好。如果`select`语句中有多个channels准备好，那么Go运行时就会在这些准备好的channles中随机选择一个。Go运行时在这些准备好的channels之间做随机选择时尽量做到一致和公平。
```go
 select {
   case <-ch1:
       fmt.Println("channel 1 :", <-ch1)
   case <-ch2:
     fmt.Println("channel 2 :", <-ch2)
   case <-ch3:
     fmt.Println("channel 3 :", <-ch3)
   default:
     fmt.Println("Default!")
 }
```
### 超时检查
1.  使用了`time.After()`方法
    ```go
    package main

    import (
      "fmt"
      "time"
    )

    func main() {
      c1 := make(chan string)
      go func() {
        time.Sleep(time.Second * 3)
        c1 <- "c1 OK"
      }()
      
      select {
        case res := <-c1:
          fmt.Println(res)
        case <-time.After(time.Second * 1):
          fmt.Println("timeout c1")
      }
      
      c2 := make(chan string)
      go func() {
        time.Sleep(3 * time.Second)
        c2 <- "c2 OK"
      }()
      
      select {
        case res := <-c2:
          fmt.Println(res)
        case <-time.After(4 * time.Second):
          fmt.Println("timeout c2")
      }
    }

    ```
2.  作为参数
    ```go
    package main

    import (
      "fmt"
      "os"
      "strconv"
      "sync"
      "time"
    )

    func timeout(w *sync.WaitGroup, t time.Duration) bool {
      temp := make(chan int)
      go func() {
        time.Sleep(5 * time.Second)
        defer close(temp)
        w.Wait()
      }()
      select {
         case <-temp: return false
         case <-time.After(t): return true
      }
    }

    func main() {
      arguments := os.Args
      if len(arguments) != 2 {
        fmt.Println("Need a time duration!")
        return
      }
      var w sync.WaitGroup
      w.Add(1)
      t, err := strconv.Atoi(arguments[1])
      if err != nil {
      fmt.Println(err)
        return
      }
      duration := time.Duration(int32(t)) * time.Millisecond
      fmt.Printf("Timeout period is %s\\\\n", duration)
      if timeout(&w, duration) {
        fmt.Println("Timed out!")
      } else {
        fmt.Println("OK!")
      }
      w.Done()
      if timeout(&w, duration) {
        fmt.Println("Timed out!")
      } else {
         fmt.Println("OK!")
      }
    }
    ```
### pipeline
channel可以连接goroutine，如果一个goroutine的输出是另一个goroutine的输入，就叫作pipeline。可以理解为pipeline是虚拟的，用来连接goroutine和channel，并且最终形成一个goroutine的输出称为另一个goroutine的输入，且是使用channel传递数据的。
使用pipeline的好处有三点：首先，在程序中形成一个清晰稳定的数据流，我们在使用的时候不需要过多考虑goroutine和channel的相关通信和状态问题。其次，在一个pipeline内，不需要把数据再保存为变量，节省了内存空间并提高了效率。最后，使用pipeline能够简化程序的复杂度，便于维护。
```go
package main

import(
  "math/rand"
  "fmt"
)

var done=false
var Mess=make(map[int]bool)

func main(){
  A:=make(chan int)
  B:=make(chan int)
  go sendRan(50,10,A)
  go receive(B,A)
  sum(B)
}

go genRandom(max,min int) int{
  return rand.lntn(max-min)+min
}

func sendRan(max,min int,out chan<-int){
  for{
    if done{
      close(out)
      return
    }
    out<-genRandom(max,min)
  }
}

func receive(out chan<- int, in<-chan int){
  for r:=range in{
    fmt.Println(" ", r)
    _,ok:=Mess[r]
    if ok{
      fmt.Println("duplicate num is :",r)
      done=true
    }else{
      Mess[r]=true
      out<-r
    }
  }
  close(out)
}

func sum(it <-chan int){
  var sum int
  for r:=range it{
    sum += r
  }
  fmt.Println("The sum is :",sum)
}
```
（上面的代码有问题）
# 包和代码测试
## 包及go工具
### 包
**包导入**
```go
import(
  . "fmt" // 使用时省略包名
  sy "sync/WaitGroup" // 别名
  _ "github.com/go-sql-driver/mysql" // 空导入，只导入包的init方法 
)
```
⚠️导入的包必须在程序内用到，否则编译无法通过。
### Go工具
go语言提供了标准工具，利用这些工具，工程师可以方便地进行下载、查询、构建、格式化、测试安装代码包等操作，这组标准工具称为go工具（Go Tool）。
Go编译器需要在go tool的帮助下执行。Go tool除了生成可执行文件之外还有许其他的功能。
生成一个`.o`为扩展名的目标文件。`go tool compile -pack main.go`会得到一个压缩包，压缩包是一个二进制文件，包含一个或者多个文件，主要目的是把多个文件组织到单个文件中。
Go使用的压缩文件被称为`ar`。`ar -t main.go`。
```go
(base) ~ ᐅ go help
Go is a tool for managing Go source code.

Usage:

  go <command> [arguments]

The commands are:

  bug         start a bug report
  build       compile packages and dependencies
  clean       remove object files and cached files
  doc         show documentation for package or symbol
  env         print Go environment information
  fix         update packages to use new APIs
  fmt         gofmt (reformat) package sources
  generate    generate Go files by processing source
  get         add dependencies to current module and install them
  install     compile and install packages and dependencies
  list        list packages or modules
  mod         module maintenance
  work        workspace maintenance
  run         compile and run Go program
  test        test packages
  tool        run specified go tool
  version     print Go version
  vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.

Additional help topics:

  buildconstraint build constraints
  buildmode       build modes
  c               calling between Go and C
  cache           build and test caching
  environment     environment variables
  filetype        file types
  go.mod          the go.mod file
  gopath          GOPATH environment variable
  gopath-get      legacy GOPATH go get
  goproxy         module proxy protocol
  importpath      import path syntax
  modules         modules, module versions, and more
  module-get      module-aware go get
  module-auth     module authentication using go.sum
  packages        package lists and patterns
  private         configuration for downloading non-public code
  testflag        testing flags
  testfunc        testing functions
  vcs             controlling version control with GOVCS

Use "go help <topic>" for more information about that topic.

```
**环境变量**
1.  GOPATH
    指定工作空间的根目录
2.  GOROOT
    保存go语言标准包的根目录
3.  GOOS和GORACH
    GOOS指定操作系统，GORACH存储指定目标处理器的架构
**Go命令**
1.  go get
2.  go build
3.  go install&#x20;
4.  go list
5.  go doc与godoc
**go build**
```bash
go build -o ./a.o 默认在当前路径生成一个编译后的.o格式文件。
go build -a 强制重新编译所有包（含标准库），在本地生成一个可执行文件。
go build -p 指定可以并行可运行的编译数目，默认是CPU数目。
go build -v 打印正在编译的包名。
go build -n 仅显示编译命令，但是不执行。
go build -x 显示正在执行的命名。
go build -work 显示临时工作目录，完成后不删除。
go build -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位机器。
go build -gcflags 编译器参数。
    -B：禁用越界检查
    -N：禁用优化
    -l：禁用内联
    -u：禁用unsafe
    -m：输出优化信息
    -S：输出汇编代码
go build -ldflags 链接器参数。
    -s：禁用符号表
    -w：禁用DRAWF调试信息
    -X：设置字符串全局变量值 -X ver="0.99"
    -H：这只可执行文件格式 -H windowsgui
```
**go install**
和`go build`参数相同，但是会将编译结果安装到bin，pkg目录。关键是`go install`支持增量编译，在没有修改的情况下，会直接链接pkg目录中的静态包。
编译器用`builddid`检查文件清单和导入依赖，对比现有静态库和所有源文件修改时间来判断源码是否变化，以此来决定是否需要对包进行重新编译。
`buildid`：将包的全部文件名，运行时版本号，所有导入的第三方包信息（路径`buildid`）数据合并后哈希。
**go clean**
清理工作目录
-   \-i：清理`go install`安装的文件
-   \-r：递归清理所有依赖包
-   \-x：显示正在执行的清理命令
-   \-n：仅显示清理命令，但不执行
### 代码格式化
在提交代码之前可以使用`gofmt`格式化代码。
1.  `gofmt -s`简化代码；
2.  `gofmt -r`执行代码“微重构”；
3.  `gofmt -l`按格式要求输出满足条件的文件列表；
Go编译器在编译源码时会对源码文件导入的包进行检查，对于源文件中没有使用但没有导入的包，Go编译器都会报错。于是Go团队在gofmt的基础上实现了goimports。
goimports在gofmt功能的基础上增加了对包导入列表的维护功能，可根据源码的最新变动自动从导入包列表中增删包。
安装goimports：
`go install golang.org/x/tools/cmd/goimports`
### 交叉编译
交叉编译不支持`CGO`。
1.  Mac下编译Linux, Windows平台的64位可执行程序
```bash
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go   
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go
```
1.  Linux下编译Mac, Windows平台的64位可执行程序
```bash
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.go
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go
```
1.  Windows下编译Mac, Linux平台的64位可执行程序
```bash
SET CGO_ENABLED=0SET GOOS=darwin3 SET GOARCH=amd64 go build test.go
SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build  test.go
```
### 条件编译
除在代码中用`runtime.GOOS`进行判断外，编译器本身就支持文件级别的条件编译。
1.  将平台和架构信息添加到文件名尾部
    ```bash
    hello_*drawin.go hello_linux.go*
    ```
2.  使用`build`编译指令
    ```bash
    1. // +build windows
    2. //+build linux darwin
    可以添加多条build，表示多个AND条件，在单一指令里，空格表示OR条件，逗号表示AND 感叹号表示NOT
    // +build linux darwin
    // +build 386,!cgo

    相当于 （linux or darwin）AND (386 AND (NOT cgo))
    ```
3.  使用`tag`指令
```bash
// +build !release

go build -tags "release " && ./test
```
### 预处理（没有实践过）
用`go generate`命令扫描源码文件，找出所有go:generate注释，提取其中的命令并执行
-   命令必须放在`.go`源文件中
-   命令必须以`//go:generate`开头双斜线后不能有空格
-   每个文件可有多条`generate`命令
-   命令支持环境变量
-   必须显示执行`go generate`命令
-   按文件名顺序提取命令并执行
-   串行执行，出错后终止后续命令的执行
## 代码优化
### 性能分析
为了更方便地分析代码，go语言提供了runtime/pprof标准库。
runtime/ pprof是比较底层的包，常用于代码分析。不 过在后面要讲的Web编程中，一般使用net/http/ pprof标准 包，其底层也是runtime/ pprof,第9章会进行介绍。
（这里在仔细看一遍）
## 测试
Go语言中的测试依赖`go test`命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。`go test`命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以`_test.go`为后缀名的源代码文件都是`go test`测试的一部分，不会被`go build`编译到最终的可执行文件中。在`*_test.go`文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。
![](https://cdn.nlark.com/yuque/0/2023/png/12729563/1673071319427-bea1c931-2899-4000-bce2-72c18a3b79ad.png)
**go test的参数**
1.  `-args`：给测试程序传递参数；
2.  `-c`：将测试二进制文件编译为`pkg.test`，但不要运行它；
3.  `-exec`：使用xprog运行测试二进制文件；
4.  `-i`：安装作为测试依赖项的包，不运行测试；
5.  `-json`：使用json格式的测试输出；
6.  `-o file`：编译测试文件；
# Go Web编程
## net/http包
### Go Web工作基本原理
**Request**
Request是http请求，里面包含了浏览器端的有关信息。
**Response**
Response是http请求的响应，这些数据是需要返回给浏览器端的数据。
**Conn**
Conn是http的请求连接。
**Handler**
Handler是接收请求后逻辑处理和生成返回信息的逻辑。
![](https://article.biliimg.com/bfs/article/133228350b0cfca56da7b4f988eb98de32712ae5.png)

**Web开发的主要步骤**

1.  创建实例监听端口的请求，等待请求的到来
2.  接收客户端请求，得以连接Conn，接下来使用这个Conn与浏览器通信
3.  处理请求，从请求中读取http的协议头数据，如果是POST方法，可能还需要读取客户端提交的数据，接下来交给handler处理，待handler处理完毕后，将结果通过Conn返回给客户端

⚠️一个Conn就是一个goroutine，http包对并发处理直接使用了go语言原生的并发方式。其实还有一个第三方fasthttp Web框架，它使用的是自己的workpool，其性能更优。

### http详解

。。。

## Web框架

### httprouter框架

## Web底层服务

## Socket简介

Socket也被称为“套接字”，是计算机之间通信的一种约定。通过Socket这种约定可以接收其他计算机的数据，也可 以向其他计算机发送数据。Socket原意 是“插座”，设计的本意为“像通电一样在计算机之间通信”。

Socket最典型的应用就是刚刚介绍的Web服务的通信,浏览器会根据URL向服务器发起http请求;服务器分析接收到的URL，然后将对应的资源以response方式返回，最后浏览器经过解析和渲染，将文字、图片、视频等元素呈现给用户。

Socket开始主要是在Unix或L inux之间工作，所以借鉴了Unix“一-切皆文件”的理念。即把网络连接也看作一个文件， 进行read、write和close操作 。

Socket可以分为两种类型：

1.  面向连接的流式Socket，如TCP Socket
2.  面向数据包的无连接Socket，如UDP Socket

#### **TCP Socket**

TCP Socket的连接在go语言的net包中被定义为TCPConn类型。

TCP是面向连接的，每次都是客户端先建立一个连接，然后再写入数据；服务器则通过net.Accept函数接收连接，收到数据后使用这个连接写回数据。

```go
package main

import (
  "fmt"
  "io/ioutil"
  "net"
  "os"
)

func main(){
  addr:="www.baidu.com:80"
  tcpAddr,err:=net.ResolveTCPAddr("tcp",addr)
  if err!=nil{
    fmt.Println("Error:",err.Error())
    return
  }
  myConn,err:=net.DialTCP("tcp", nil, tcpAddr)
  if err!=nil{
    fmt.Println("Error:",err.Error())
    return
  }
  _,err=myConn.Write([]byte("HEAD / HTTP/1.1\r\n\r\n"))
  result,err:=ioutil.ReadAll(myConn)
  if err!=nil{
    fmt.Println("Error:",err.Error())
    return
  }
  fmt.Println(string(result))
  os.Exit(0)
}
```

#### **UDP Socket**

UDP是没有连接的，UDP客户端按照一定的报文格式直接向UDP服务器发送数据包的。服务器收到数据包后解析得到请求数据，处理完成后再以数据包的方式发送给客户端。这一来一回不是使用一个连接，而是单独的多次数据发送。

（代码和上面插不对，把TCP改成UDP就差不多了）

#### **WebSocket**

以前，为了实现“推送”的功能，就会使用客户端轮询的方式给服务器发送请求。这种方式的缺点就是请求携带较大的header数据，浪费资源。

WebSocket与http和https使用了相同的TCP端口，可以绕过大多数防火墙限制。默认情况下，









## 中间件
# 微服务理论

## 微服务

微服务的架构风格是将单个应用作为一组小型服务进行开发，每个服务都运行在自己的进城环境中，并通过轻量级机制（比如HTTP协议）进行通信。这些服务紧密围绕业务功能进行构建，可以通过自动化的方式进行部署。不同的服务之间可以采用不同的编程语言，并且管理方式尽可能不采用中央集中式。

## 系统架构的演进

1.  单体架构
2.  垂直架构
3.  SOA
4.  微服务架构

## 微服务化策略

微服务有两种风格：（1）每个服务都拥有独立的数据库；（2）系统基于API的模块化；

每个微服务拥有独立的数据库表这种方式，让整个系统以松耦合的方式进行整合。遵循了SRP（Single Repository Principle）原则。

通过API进行模块化可以避免随着应用的增大而导致内部关系复杂。

## 微服务的重点问题

**微服务的通信**

注意一下几个方面：

1.  通信风格
2.  服务发现
3.  可靠性
4.  事务性消息
5.  外部API

**事物管理一致性**

**微服务数据查询**

有时候使用调用多个API，然后将数据聚合的方式；更多的时候使用命令查询指责分离（CQRS）的方式。

**微服务部署**

1.  单主机多服务模式
2.  单主机单服务模式
3.  单容器单服务模式

**微服务生产环境监控**

1.  API状态
2.  日志集中处理
3.  请求追踪
4.  异常跟踪
5.  运行指标
6.  行为日志

**微服务的自动化测试**

## 微服务的拆分

**拆分的指导原则**

1.  单一职责原则：修改一个微服务应该只有一个理由
2.  闭包原则：所有的依赖都在这个微服务中

依据业务能力分

依据领域驱动分


## 微服务中进程的通信

### protobuf

protobuf (Google Protocol Buffer) 是Google旗下的一种平台无关、语言无关、可扩展的序列化结构数据格式，很适合作为数据存储和不同语言之间相互通信的数据交换格式。在项目中，工程师只要编写一个协议格式（同一proto文件）文件即可，该proto文件将被编译成不同的语言版本加入到各自的工程中去。这样，不同的语言就可以解析其他语言通过protobuf序列化的数据了。目前官网针对 C++、Python、Java、 Go等语言提供了支持。

**protobuf的优点**

1.  序列化之后体积小，便于传输
2.  跨平台、跨语言
3.  很好的“向后”兼容性
4.  序列化和反序列化的速度快，高于JSON的处理速度
**先安装protobuf文件库**
```shell
go get github.com/golang/protobuf/proto
```
**再安装插件**
```shell
go get github.com/golang/protobuf/protoc-gen-go
```




### net/rpc包


### gRPC包


### 微服务发现：consul
当需要调用一个微服务时，需要知道要调用的服务的IP地址。在Go语言微服务中，实现服务发现最有名的工具就是Consul。
Consul的特色：
1. 服务发现
2. 健康检测
3. 键/值存储
4. 多数据中心
![Pasted image 20230214103213](https://article.biliimg.com/bfs/article/d1b74c96f887c47a2eb62422fbeadc45180e5912.png)
从A到N的服务都注册在服务发现模块内，在Consul内就是使用K-V形式存储的，K一般是服务的名字，V就是IP地址和PORT。





## 微服务中分布式事务管理

## 领域事件

## Go语言领域驱动模型的实践

## 微服务中的测试

## 微服务运行环境：Docker

## Go语言基于ES-CQRS的微服务实战

# 微服务实战

# 日志和监控

# 持续交付

# 使用Go kit框架构建微服务


